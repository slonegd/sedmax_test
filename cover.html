
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">/home/slonegd/code/go_web/database.go (78.0%)</option>
				
				<option value="file1">/home/slonegd/code/go_web/main.go (43.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "time"
import "sync"
import "net"
import "net/http"
import "fmt"
import "strings"

// Value ...
type Value struct {
        value   string
        elapsed time.Time
}

// Database ...
type Database struct {
        sync.Mutex
        values map[string]Value
        livingTime time.Duration
        tasks  chan task
}

// MakeDatabase ...
func MakeDatabase(taskQty, workersQty, livingTime int) (p *Database) <span class="cov8" title="1">{
        p = &amp;Database{
                values: make(map[string]Value),
                livingTime : time.Duration(livingTime*1000000000), // in seconds
                tasks:  make(chan task, taskQty),
        }
        for i := 0; i &lt; workersQty; i++ </span><span class="cov8" title="1">{
                go worker(p.tasks, p)
        }</span>
        <span class="cov8" title="1">return</span>
}

type task struct {
        command string
        conn    net.Conn
}

func worker(tasks &lt;-chan task, d *Database) <span class="cov8" title="1">{
        for t := range tasks </span><span class="cov8" title="1">{
                d.parseAndAnswer(t)
        }</span>
}

// HTTPresponse ...
func (d *Database) HTTPresponse(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        now := time.Now()
        w.Write([]byte("{"))
        notFirst := false
        d.Lock()
        for key, v := range d.values </span><span class="cov0" title="0">{
                if v.elapsed.After(now) </span><span class="cov0" title="0">{
                        if notFirst </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, ",")
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(w, "\n  \"%s\" : \"%s\"", key, v.value)
                        notFirst = true</span>
                } else<span class="cov0" title="0"> {
                        delete(d.values, key)
                }</span>
        }
        <span class="cov0" title="0">d.Unlock()
        w.Write([]byte("\n}\n"))</span>
}

// AddTask ...
func (d *Database) AddTask(command string, conn net.Conn) <span class="cov8" title="1">{
        d.tasks &lt;- task {command, conn}
}</span>

func (d *Database) parseAndAnswer(t task) <span class="cov8" title="1">{
        strs := strings.Split(t.command, " ")
        const (
                command = iota
                key
                value
        )

        if strings.Compare(strs[command], "INSERT") == 0 &amp;&amp; len(strs) == 3 </span><span class="cov8" title="1">{
                d.addValue(strs[key], strs[value], t.conn)
                return
        }</span>

        <span class="cov8" title="1">if strings.Compare(strs[command], "GET") == 0 &amp;&amp; len(strs) == 2 </span><span class="cov8" title="1">{
                d.getValue(strs[key], t.conn)
                return
        }</span>

        <span class="cov8" title="1">if strings.Compare(strs[command], "DELETE") == 0 &amp;&amp; len(strs) == 2 </span><span class="cov8" title="1">{
                d.deleteValue(strs[key], t.conn)
                return
        }</span>
}

func (d *Database) addValue(key, value string, conn net.Conn) <span class="cov8" title="1">{
        d.Lock()
        defer d.Unlock()
        v, exist := d.values[key]
        switch </span>{
        case !exist:<span class="cov8" title="1">
                d.values[key] = Value{
                        value,
                        time.Now().Add(d.livingTime),
                }
                write("OK", conn)</span>
        case v.value != value:<span class="cov8" title="1">
                d.values[key] = Value{
                        value,
                        time.Now().Add(d.livingTime),
                }
                write("OK", conn)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (d *Database) getValue(key string, conn net.Conn) <span class="cov8" title="1">{
        now := time.Now()
        d.Lock()
        defer d.Unlock()
        v, exist := d.values[key]
        if exist &amp;&amp; v.elapsed.After(now) </span><span class="cov8" title="1">{
                write(v.value, conn)
        }</span> else<span class="cov8" title="1"> {
                write("ERR", conn)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (d *Database) deleteValue(key string, conn net.Conn) <span class="cov8" title="1">{
        now := time.Now()
        d.Lock()
        defer d.Unlock()
        v, exist := d.values[key]
        if exist </span><span class="cov8" title="1">{
                if v.elapsed.After(now) </span><span class="cov8" title="1">{
                        write("OK", conn)
                }</span> else<span class="cov8" title="1"> {
                        write("ERR", conn)
                }</span>
                <span class="cov8" title="1">delete(d.values, key)</span>
        } else<span class="cov8" title="1"> {
                write("ERR", conn)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import "bufio"
import "fmt"
import "net"
import "net/http"
import "flag"

func main() <span class="cov0" title="0">{
        taskQty := flag.Int("task", 100, "max task for database changes")
        workersQty := flag.Int("worker", 4, "max workers for database changes")
        HTTPport := flag.Int("http", 8080, "port for http")
        TCPport := flag.Int("tcp", 5000, "port for tcp")
        livingTime := flag.Int("time", 60, "living time for keys in second")
        flag.Parse()

        database := MakeDatabase(*taskQty, *workersQty, *livingTime)

        go listenTCP(*TCPport, database)
        http.HandleFunc("/", database.HTTPresponse)
        http.ListenAndServe(fmt.Sprintf(":%d", *HTTPport), nil)
}</span>

func listenTCP(port int, database *Database) <span class="cov0" title="0">{
        listener, _ := net.Listen("tcp", fmt.Sprintf(":%d", port))

        for </span><span class="cov0" title="0">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        conn.Close()
                        continue</span>
                }
                <span class="cov0" title="0">go handlerTCP(conn, database)</span>
        }
}

func handlerTCP(conn net.Conn, database *Database) <span class="cov8" title="1">{
        defer conn.Close()
        for </span><span class="cov8" title="1">{
                in := bufio.NewReader(conn)
                str, errR := in.ReadString('\n')
                if errR != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">str = str[:len(str)-1]
                if str[len(str)-1] == '\r' </span><span class="cov8" title="1">{
                        str = str[:len(str)-1]
                }</span>
                <span class="cov8" title="1">database.AddTask(str, conn)</span>
        }
}

func write(s string, conn net.Conn) <span class="cov8" title="1">{
        _, errW := conn.Write([]byte(s + "\n"))
        if errW != nil </span><span class="cov8" title="1">{
                conn.Close()
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
